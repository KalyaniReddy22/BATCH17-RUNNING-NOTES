    IF SHELL SCRIPTING IS ALREADY THERE, WHY PYTHON?

    --------------------------------------------------
    SHELL SCRIPTING (WHAT IT IS)
    --------------------------------------------------

        - A command-line interpreter and scripting language for Unix/Linux systems.
        - Mainly used to automate Linux commands and OS-level tasks.
        - Ideal for:
              • File operations
              • System administration
              • Package installation
              • Cron jobs
              • Service management
        - Not designed for complex programming.
        - Works best only on Unix-like systems (Linux, macOS).
        - Windows uses PowerShell instead, not Bash.


    --------------------------------------------------
    WHY PYTHON IS NEEDED (EVEN IF SHELL EXISTS)
    --------------------------------------------------

        - Python is a full programming language.
        - Handles complex automation that shell cannot.
        - Required for modern DevOps automation:
              • AWS / Azure / GCP automation
              • CI/CD integrations
              • API-based automation
              • CloudOps scripting
        - Cross-platform (Linux, Windows, macOS)
        - Easy to learn, clean syntax, very powerful.
        - Faster automation with fewer lines of code.

        Summary:
            Shell → OS-level automation (Low level automation)
            Python → High-level automation + APIs + DevOps tools


    --------------------------------------------------
    PYTHON (WHAT IT IS)
    --------------------------------------------------

        - A high-level, general-purpose programming language.
        - Clean and readable syntax.
        - Supports multiple paradigms:
              • Object-Oriented
              • Functional
              • Procedural
        - Used for:
              • Web development
              • Data analysis
              • Machine learning
              • DevOps automation (scope of our course) 
              • Scientific computing

        DevOps scope:
            Python scripting + API automation only.

        OOP Concepts supported:
            - Classes
            - Objects
            - Inheritance
            - Encapsulation
            - Polymorphism
            - Abstraction


    --------------------------------------------------
    WHAT IS A PROGRAM?
    --------------------------------------------------

        - A collection of instructions written in code.
        - Passed to computer --> CPU → Processor executes instructions.
        - Programs manipulate data.
        - Data is stored using variables.


    --------------------------------------------------
    WHAT IS A VARIABLE?
    --------------------------------------------------

        - A container used to store data.
        - Example:

              x = "madhu"
              x = 10
              x = 10.3
              x = 3+4j


    --------------------------------------------------
    WHAT IS A DATA TYPE?
    --------------------------------------------------

        - Defines what type of value a variable stores.

        Common types:
            Text      → str
            Numeric   → int, float, complex
            Boolean   → bool (True/False)

        Collection types (can store multiple values):
            list, tuple, set, dictionary


        Example:
            X = [10, 9.8, "KIRAN", True] 


    --------------------------------------------------
    READING INPUT & PRINTING OUTPUT
    --------------------------------------------------

        In Linux (shell):

            echo "Enter your name"
            read name
            echo "Value of name is $name"

        In Python:

            name = input("Enter your name: ")
            print(f"Hello,", {name})

        Shell script example:

            #!/bin/bash
            read -p "Enter your name: " name
            echo "Hello, $name"


    --------------------------------------------------
    OPERATORS
    --------------------------------------------------

        Arithmetic:
            +  -  *  /  %

        Assignment:
            =  +=  -=  *=
			
			a = 10
			a+=2  --> a = a + 2
			

        Comparison:
            <  >  <=  >=  ==  !=
            Shell equivalents: -eq -lt -le -gt -ge

        Logical:
            and, or, not

        Identity:
            is, is not

        Membership:
            in, not in

        Bitwise:
            & | ^ ~


    --------------------------------------------------
    PYTHON EXAMPLE
    --------------------------------------------------

        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))

        sum = num1 + num2

        print(f"The sum of {num1} and {num2} is: {sum}")


    --------------------------------------------------
    SHELL EXAMPLE
    --------------------------------------------------

        #!/bin/bash
		
		echo "ENter numer 1"
        read num1
		
	    echo "ENter numer 2"
        read num2
		
        sum=$((num1+num2))
        echo "Sum of 2 numbers : $sum"


    --------------------------------------------------
    ADVANCED DATA TYPES (COLLECTION TYPES)
    --------------------------------------------------

     x = [ 10, madhu, 5.3, 4+3i ]

        List:
            - Ordered
            - Mutable
            - Allows duplicates
            list = [1, 2, 3, 1]

        Tuple:
            - Ordered
            - Immutable
            - Allows duplicates
            tuple = (1, 2, 3, 1)

        Set:
            - Unordered
            - No duplicates
            - No index
			- unique values 
			
            set = {1, 2, 3}

        Dictionary:
            - Unordered
            - Mutable
            - Key-value pairs
            dict = {
			         "name": "Madhu", 
			         "age": 30
					 "address: "xyz"
                     "prof" : "abc" 

					 }


    --------------------------------------------------
    REAL DEVOPS EXAMPLES
    --------------------------------------------------



Real-Time DevOps Examples 

List:

Server IPs: 
       A list of IP addresses of servers in a Cluster, which may change as servers are added or removed.

   - Server IPs: ['192.168.3.2', '192.168.1.2', '10.81.0.3'] 

   
==============================


Tuple:

Server Configuration: 
          A tuple containing details of server configuration  (IP, OS, version). These values are fixed Once set, these details should not change.
		  
          Immutable System Settings: Information about the region, availability zone, and instance type, which remains constant for the duration of a deployment.
		  
   - Server Configuration: ('192.168.1.1', 'Ubuntu', '18.04') 
   - Immutable System Settings: ('US-East', 'us-east-1a', 'm5.large')		  
		  
====================
	  
Set:

    Active Services --- A set of active services running on a server, where uniqueness (no duplicates) is crucial.
	
    Unique Error Codes ---A set of unique error codes encountered during operations, useful for monitoring and alerting.

	- Active Services: {'nginx', 'redis', 'mysql', 'jenkins'} 
	- Unique Error Codes: {404, 500, 502}
	
=====================

Dictionaries :	
	
    Environment Variables: Key-value pairs representing environment variables for an application, where keys are unique and values can vary.
	
    Configurations: Dictionary of configurations, such as timeout settings and retry limits, where keys represent the setting and values are the parameters

    - Environment Variables: {
	                          'DB_HOST': 'mcdb.example.com', 
	                           'DB_USER': 'admin'
							   
							   
							   } 
	
    - Configurations: {
	
	                   'timeout': 30, 
					   'retries': 3
					   }
					   
					   
	    dict = {
			         "name": "Madhu", 
			         "age": 30
					 "address: "xyz"
                     "prof" : "abc" 

					 }


========================================================

        LIST
            Server IPs:
                ["192.168.1.1", "192.168.1.2", "10.81.0.3"]

        TUPLE
            Immutable server config:
                ("192.168.1.1", "Ubuntu", "18.04")

        SET
            Active services:
                {"nginx", "redis", "mysql"}

            Unique error codes:
                {404, 500, 502}

        DICTIONARY
            Environment variables:
                {"DB_HOST": "db.example.com", "DB_USER": "admin"}

            Configurations:
                {"timeout": 30, "retries": 3}


==================================================

    --------------------------------------------------
    PRACTICAL EXAMPLES
    --------------------------------------------------

        Remove duplicates from list:

            usernames = ["madhu", "kiran", "madhu", "raja" ]
            unique = list(set(usernames))

        Contact book:

            contact = {
                "name": "Madhu",
                "phone": "73966",
                "email": "devops@gmail.com"
            }

            contact_book = [
     
                {"name": "xyz",   "phone": "...","email": "abc@gmail.com"},
				{                                                        },
				{"name": "Madhu", "phone": "...", "email": "abc@gmail.com"},
            ]

===============================================================================

========================================================


	FUNCTIONS 
          -- BLOCK OF CODE FOR REPEATED USE 
		  -- ALLOWS TO GROUP A SET OF COMMANDS INTO A SINGLE, REUSABLE UNIT. 
		  -- BREAK DOWN TOTAL FUNCTIONALITY OF SCRIPT INTO LOGICAL SUB-SECTIONS 
          -- ENCAPSULATE AND REUSE CODE
		  -- WE CAN CALL FUNCTIONS WHEN EVER NEEDED
		  -- MAKE YOUR SCRIPTS MORE ORGANIZED, MODULAR, AND EASIER TO MAINTAIN.
		  
	

============================================================

FUNCTIONS IN PYTHON: 

# Python example

def greet(name):
    print(f"Hello, {name}!")

greet("Madhu")	

====================================================================


FUNCTIONS IN SHELL : 
# Bash example

greet() {
  echo "Hello, $1!"
}

greet "Madhu"

greet "kiran"

=================================


LINUX :

yum install python -y 
apt install python -y 

WINDOWS: 

DOWNLOAD & INSTALL 
================================================================

DATE:
17 JAN 26


PYTHON VS SHELL, FUNCTIONS, AND DATA TYPES (NOTES)

    --------------------------------------------------
    PYTHON TRACING (DEBUGGING)
    --------------------------------------------------

        Run script with tracing:

            python3 -m trace --trace script.py


    --------------------------------------------------
    SHELL FUNCTION EXAMPLE
    --------------------------------------------------

        #!/bin/bash

        greet() {
            echo "Hello, $1!"
        }

        greet "Madhu"
        greet "Kiran"


    --------------------------------------------------
    PYTHON FUNCTION EXAMPLE
    --------------------------------------------------

        def greet(name):
            print(f"Hello, {name}!")

        greet("Madhu")
        greet("Kiran")


    --------------------------------------------------
    SHELL FUNCTION WITH set -x (DEBUGGING)
    --------------------------------------------------

        #!/bin/bash

        set -x
        sum() {
            result=$(( $1 + $2 ))
            echo "The sum of $1 and $2 is $result"
        }

        sum 5 10
        sum 20 30
        sum 100 250


    --------------------------------------------------
    PYTHON SUM FUNCTION
    --------------------------------------------------

        def sum(a, b):
            result = a + b
            print(f"The sum of {a} and {b} is {result}")

        sum(5, 10)
        sum(20, 30)
        sum(100, 250)


    --------------------------------------------------
    PYTHON FUNCTION WITH RETURN
    --------------------------------------------------

        def add_numbers(a, b):
            result = a + b
            return result

        num1 = float(input("Enter first number: "))
        num2 = float(input("Enter second number: "))

        sum_result = add_numbers(num1, num2)
        print(f"The sum of {num1} and {num2} is {sum_result}")


    ==================================================
    LIST OPERATIONS USING FUNCTIONS & METHODS :
    ==================================================

        my_list = [1, 2, 3, 4, 5]

        my_list.append(4)
        print("After append:", my_list)

        my_list.extend([8, 9, 7])
        print("After extend:", my_list)

        my_list.insert(0, 10)
        print("After insert:", my_list)

        my_list.remove(1)
        print("After remove:", my_list)

        popped_element = my_list.pop()
        print("Popped element:", popped_element)
        print("After pop:", my_list)

        index_of_9 = my_list.index(9)
        print("Index of 9:", index_of_9)

        count_of_1 = my_list.count(1)
        print("Count of 1:", count_of_1)

        my_list.sort()
        print("After sort:", my_list)

        my_list.reverse()
        print("After reverse:", my_list)

        copied_list = my_list.copy()
        print("Copied list:", copied_list)

        my_list.clear()
        print("After clear:", my_list)

        print("Length of list:", len(my_list))
        print("Length of copied list:", len(copied_list))
        print("Maximum:", max(copied_list))
        print("Minimum:", min(copied_list))
        print("Sum:", sum(copied_list))


    ==================================================
    TUPLE – OPERATIONS (IMMUTABLE)
    ==================================================
	
	Immutability: Tuples cannot be modified once created. 

    Methods like append(), remove(), pop(), etc., are not available.

        my_tuple = (3, 1, 4, 1, 5, 9, 2, 6, 5)

        count_of_1 = my_tuple.count(1)
        print("Count of 1:", count_of_1)

        index_of_9 = my_tuple.index(9)
        print("Index of 9:", index_of_9)

        print("Length:", len(my_tuple))
        print("Max:", max(my_tuple))
        print("Min:", min(my_tuple))
        print("Sum:", sum(my_tuple))

        sorted_list = sorted(my_tuple)
        print("Sorted tuple as list:", sorted_list)

        sorted_list.append(4)
        print("After append:", sorted_list)


    ==================================================
    SETS – OPERATIONS (NO DUPLICATES)
    ==================================================
    No Duplicate Elements:   Sets automatically remove duplicate elements.
    Unordered: Sets do not maintain the order of elements.
    Mutable: You can add or remove elements from a set.
	Use Cases: Sets are useful for removing duplicates from a collection, checking for membership, and performing set operations like union, intersection, and difference.


        my_set = {1, 2, 3, 4, 5}

        my_set.add(6)
        print("After add:", my_set)

        my_set.remove(4)
        print("After remove:", my_set)

        popped = my_set.pop()
        print("Popped:", popped)
        print("After pop:", my_set)

        my_set.clear()
        print("After clear:", my_set)

        set_a = {1, 2, 3}
        set_b = {3, 4, 5}

        print("Union:", set_a.union(set_b))
        print("Intersection:", set_a.intersection(set_b))
        print("Difference:", set_a.difference(set_b))


    ==================================================
    DICTIONARIES – OPERATIONS
    ==================================================

        my_dict = {
            "name": "Madhu",
            "phone": "7396627149",
            "city": "Hyderabad"
        }

        print("Name:", my_dict['name'])

        phone = my_dict.get('phone')
        print("Phone:", phone)

        salary = my_dict.get('salary', 'Not Available')
        print("Salary:", salary)

        my_dict['occupation'] = 'DevOps Engineer'
        print("After adding occupation:", my_dict)

        popped_value = my_dict.pop('phone')
        print("Popped:", popped_value)
        print("After pop:", my_dict)

        print("Keys:", list(my_dict.keys()))
        print("Values:", list(my_dict.values()))
        print("Items:", list(my_dict.items()))

        my_dict.clear()
        print("After clear:", my_dict)

        new_dict = {'a': 1, 'b': 2}
        copied_dict = new_dict.copy()
        print("Copied:", copied_dict)


======================================
    FUNCTIONS VS METHODS IN PYTHON

    --------------------------------------------------
    WHAT IS A FUNCTION?
    --------------------------------------------------

        A function is a standalone block of code that:

            - Is not tied to any object
            - Takes data as arguments
            - Returns a result

        Examples (built-in functions):

            len(my_list)
            max(my_list)
            sum(my_list)

        General form:

            function_name(data)

        Your examples:

            len(my_list)
            max(copied_list)
            min(copied_list)
            sum(copied_list)

        These:

            ✔ Work on data you pass
            ✔ Do NOT belong to the data itself (not part of list)


    --------------------------------------------------
    WHAT IS A METHOD?
    --------------------------------------------------

        A method is a function that belongs to an object.

        In Python:

            - Methods are defined inside a class
            - They are called using an object

        Examples:

            my_list.append(4)
            my_list.sort()

        General form:

            object.method(arguments)

        Your examples:

            my_list.append(4)
            my_list.extend([8, 9, 7])
            my_list.insert(0, 10)
            my_list.remove(1)
            my_list.pop()
            my_list.sort()
            my_list.reverse()
            my_list.copy()
            my_list.clear()

        These:

            ✔ Belong to the list object
            ✔ Know how to modify the list


    --------------------------------------------------
    WHY append() IS NOT A FUNCTION
    --------------------------------------------------

        This will fail:

            append(my_list, 4)     (❌ invalid)

        Because append is a method defined inside the list class.

        Correct usage:

            my_list.append(4)


    --------------------------------------------------
    WHY len() IS NOT A METHOD
    --------------------------------------------------

        This will fail:

            my_list.len()      (❌ invalid)

        Because len() is a built-in function, not a method.

        Correct:

            len(my_list)


    --------------------------------------------------
    USAGE:
    --------------------------------------------------

        Function:

            function(data)
			greet(name)
			sum (num1, num2))

        Method:

            data.method()
            mylist.append()



    --------------------------------------------------
    WHY PYTHON HAS BOTH
    --------------------------------------------------

        Functions:
            - Generic
            - Work on many data types
            - Examples: len(), type(), sum()

        Methods:
            - Specific to a particular data type
            - Modify or act on that object
            - Examples: list.append(), str.upper()


    --------------------------------------------------
    FUNCTION VS METHOD (SIDE-BY-SIDE)
    --------------------------------------------------

        Feature                     Function        Method
        ----------------------------------------------------
        Belongs to object          No              Yes
        Called using               function(x)     x.method()
        Defined in                 Global/module   Class
        Needs object               Passed          Implicit (self)
        Example                    len(x)          x.append(4)


    --------------------------------------------------
    CLASSIFICATION OF YOUR CODE
    --------------------------------------------------

        LIST METHODS (object methods):

            append()
            extend()
            insert()
            remove()
            pop()
            index()
            count()
            sort()
            reverse()
            copy()
            clear()

        BUILT-IN FUNCTIONS:

            len()
            max()
            min()
            sum()


    --------------------------------------------------
    FINAL TAKEAWAY (MEMORIZE THIS)
    --------------------------------------------------

        If you call it like:

            object.something()

        → It is a METHOD.

        If you call it like:

            something(object)

        → It is a FUNCTION.


====================================================================================

x = 10
x = "madhu"
x = 10.2
x = 4 + 3j


STATICALLY TYPED  VS DYNAMIC TYPED 
Dynamic typing means that the type of a variable is determined at runtime, not in advance. You do not need to declare the type of a variable when you create it. 


Static typing means that the type of a variable is known at compile time. You must declare the type of a variable before you use it, and this type cannot change throughout the program. Languages like C, C++, go  and Java are statically typed.

======================================================================

DATE: 19 JAN 26


STRING MANIPULATION WITH in built METHONS /FUNCTIONS in python :



my_string = "Hello, Welcome to Aws Devops World"

# 1. Length of the string
print(f"Length of the string: {len(my_string)}")

# 2. Convert to uppercase and lowercase
print(f"Uppercase: {my_string.upper()}")
print(f"Lowercase: {my_string.lower()}")

# 3. Count occurrences of a substring
substring = "Welcome"
print(f"Occurrences of '{substring}': {my_string.count(substring)}")

# 4. Check if the string starts or ends with a particular substring
print(f"Starts with 'Hello': {my_string.startswith('Hello')}")
print(f"Ends with 'World.': {my_string.endswith('World')}")

# 5. Find the index of a substring (first occurrence)
print(f"Index of 'World': {my_string.find('World')}")

# 6. Replace a substring with another substring
new_string = my_string.replace('Aws', 'Cloud')
print(f"Original string: {my_string}")
print(f"Modified string: {new_string}")

# 7. Split the string into a list based on a delimiter
words = my_string.split()
print(f"Split into words: {words}")

# 8. Check if all characters are alphanumeric
alphanumeric_string = "Python123"
print(f"Is Python123 alphanumeric? {alphanumeric_string.isalnum()}")

# 9. Convert string to title case
title_case_string = "python programming"
print(f"Title case: {title_case_string.title()}")


=================================================================



# Integer examples
x = 10
y = -5
z = 0

# Floating-point examples
a = 3.14
b = -0.001


# Print examples
print(f"Integers: x = {x}, y = {y}, z = {z}")
print(f"Floating-point numbers: a = {a}, b = {b}, c = {c}")


# Arithmetic operations
print(f"\nArithmetic Operations:")
print(f"x + y = {x + y}")   # Addition
print(f"x - y = {x - y}")   # Subtraction
print(f"x * y = {x * y}")   # Multiplication
print(f"x / y = {x / y}")   # Division
print(f"x % y = {x % y}")   # Modulus


# Type conversions
print(f"\nType Conversions:")
f = float(x)
print(f"Convert int {x} to float: f = {f}")

g = int(a)
print(f"Convert float {a} to int: g = {g}")




=================================================================

CONDITIONAL EXPRESSION : 


=================================================================

if condition1:
    # Block of code to execute if condition1 is True
   
elif condition2:
    # Block of code to execute if condition1 is False and condition2 is True
   
elif condition3:
    # Block of code to execute if previous conditions are False and condition3 is True
	
elif condition4:
    # Block of code to execute if previous conditions are False and condition4 is True	
   
else:
    # Block of code to execute if all previous conditions are False
   
=================================================================
cat if.sh

#!/bin/bash


read -p "Enter a number: " NUMBER

if [ $NUMBER -gt 10 ]; then
    echo "$NUMBER is greater than 10"

elif [ $NUMBER -lt 10  ]; then
    echo "$NUMBER is less than 10"

else
    echo "$NUMBER is equal to 10"

fi
=================================================================

$ cat if.py

number = float(input("Enter a number: "))

if number > 10:
    print(f"{number} is greater than 10")

elif number < 10:
    print(f"{number} is less than 10")

else:
    print(f"{number} is equal to 10")
	
	
===================================================================

PYTHON LOOPS :
      
WHILE 
FOR 

	 
	  
WHILE  LOOP:

  it enables you to execute set of commands as long as conndition is true . 
  
  once condition fails , it comes out of loop .
 
-------------------------------------------------------------------

#!/bin/bash

i=0

while [ "$i" -lt 101 ]; do
    echo "Iteration number: $i"
    ((i++))
done

echo "Loop finished!"

 
-------------------------------------------------------------------

cat while.py

i = 0 

while i < 101:
    print("Iteration number:", i)
    i = i + 1 

print("Loop finished!")
	
-------------------------------------------------------------------
BREAK & CONTINUE :

In Python, break and continue are control flow statements used inside loops (for and while). They help control the flow of loop execution based on certain conditions


**a. break Statement:

Used to exit the loop prematurely.



**b. continue Statement:

Skips the rest of the current iteration and proceeds to the next iteration of the loop.


-------------------------------------------------------------------
BREAK :


i = 0 

while i < 101:
    print("Iteration number:", i)

    if i == 5:
        print("Reached 5, breaking the loop.")
        break
    

    i = i + 1 

print("Loop finished!")
-------------------------------------------------------------------

CONTIUE: 


i = 0 

while i < 101:

    if i == 5:
        i += 1
        continue
    
    print("Iteration number:", i)

    i = i + 1 

print("Loop finished!")

==============================================================================

FOR LOOP : 

For loop operates on list of items , it repeats commands on every item in the list 

----------------
for variable in iterable:
    # Block of code to execute
    statement1
    statement2
    # More statements
	
	

-----------------------------------


mc_list = [1,2,3,4,5,6,7,8,9,10]

for mc in mc_list:
    print(f"Processing mc value: {mc}") 
    

-----------------------------------

for i in range(50,101):
    print("Iteration number:", i)



------------------   ### range(n) ---> 0 - n-1
for i in range(5):    
    print(i)

----------------

for number in range(1, 11):  ### range(k, n) ---> k ... n-1
    print(number)

----------------

fruits = ["apple", "banana", "cherry"]

for fruit in fruits:
    print(fruit)


=======================================================

def add(a,b):
    return a + b 

result = add(3, 5)
print(result)  

================================================================
LAMBDA : 

lambda arguments: expression

   - a lambda function is a small, anonymous function defined using the lambda keyword. 
   
   
    lambda: Keyword to define an anonymous function.
    arguments: The input parameters to the function.
    expression: A single expression that the function returns.
	
================================================================	
cat lambda.py


sum = lambda a, b: a + b

print("Sum of 5 and 3 is:", sum(5, 3))
print("Sum of 10 and 20 is:", sum(10, 20))


>===================================================================

Keywords In Python:

Keywords in Python are reserved words that have special meanings and purposes within the language. These keywords cannot be used as identifiers (variable names, function names, etc.) because they are part of the language syntax.

List of keywords in Python: 
 
False      await      else       import     pass   None       break      except     in         raise
True       class      finally    is         return   and        continues   for        lambda     try
as         def        from       nonlocal   while assert     del        global     not        with
async      elif       if         or         yield



Description of Keywords:


1.	Boolean Values: True, False, and None are used to represent truth values (True and False) and a null value (None).

2.	Control Flow: Keywords like if, else, elif, while, for, break, continue, pass, and return are used for controlling the flow of execution in programs.

3.	Defining Entities: def is used to define functions, class is used to define classes, and lambda is used to create anonymous functions.

4.	Exception Handling: try, except, finally, and raise are used for handling exceptions and errors in Python programs.

5.	Importing Modules: import and from are used to import modules and contents from modules.

6.	Context Managers: with is used to manage resources and contexts that need cleanup actions.

7.	Operators: and, or, and not are logical operators used for boolean operations.

8.	Asyncio: async, await, and nonlocal are used in asynchronous programming (async and await) and for accessing variables in outer scopes (nonlocal).

9.	Assertions: assert is used to assert or enforce certain conditions in the code.



===================================================================================================
NAMING CONVENTION OF VARIABLES - BEST PRACTICES : Variable Naming Rules:



1.	Variables names must start with a letter (a-z, A-Z) or an underscore (_).
2.	The remaining characters can be letters, numbers, or underscores.
3.	Variable names are case-sensitive (age, Age, and AGE are three different variables).
4.	Python keywords (like if, else, for, etc.) cannot be used as variable names.

5.  Variables can be classified into GLOBAL scope variables and LOCAL scope variables 
                based on their scope, which determines where in your code they can be accessed and modified.

================================================================				
Assigning Values to Variables:
You assign a value to a variable using the assignment operator =.
Examples:
# Assigning integers
age = 25

# Assigning floating-point numbers
height = 5.11

# Assigning strings
name = "Madhu"

# Assigning a boolean value
is_student = True

# Assigning a list
numbers = [1, 2, 3, 4, 5]

================================================================

LOCAL VS GLOBAL VARIABLES 


---------------------------------
Global Scope Variables
Global variables are defined outside of any function and can be accessed (read and modified) by any part of the code, including inside functions.

--------
Local Scope Variables

Local variables are defined within a function and are only accessible within the scope of that function. They cannot be accessed outside the function.

-----------
Global Variables and Local Variables Together:

Variables with the same name can exist both globally and locally, but they are treated as separate variables with different scopes.
Example:


------------------------------------------------- 
cat local_global.py

x = 10
y = 20

def add_numbers():
    x = 15
    y = 25  
    print(f"Sum of 2 numbers is:, {x + y}")


def multiply_numbers():
    global x
    x = 5
    y = 4  
    print(f"Product of 2 numbers is:, {x * y}")


add_numbers()
multiply_numbers()
print(f"Global Sum of 2 numbers is:, {x + y}")

===============================================================================================


MODULES & PACKAGES
   
   modules and packages are fundamental concepts used TO ORGANIZE AND STRUCTURE CODE
  
   A module is A SINGLE FILE (WITH A .PY EXTENSION) that contains Python code. It can include functions, classes, and variables. You can also include runnable code. Modules are used to organize related code into a single file and to promote code reusability.
   
 ----------------------------------------  
 # my_module.py
    

def greet(name):
    print(f"Hello, {name}!")


def add(a, b):
    result = a + b
    print(f"The sum of {a} and {b} is {result}")
----------------------------------------


# main.py

import my_module

my_module.greet("Madhukiran")
my_module.add(5, 10)
my_module.add(20, 30)
my_module.greet("Alice")    
my_module.add(7, 3)
my_module.greet("BATCH 17")


=======================================================================

PYTHON PACKAGE: 

A package is a way of organizing multiple related modules into a directory hierarchy. 
A PACKAGE IS A DIRECTORY THAT CONTAINS A SPECIAL FILE NAMED __INIT__.PY (WHICH CAN BE EMPTY) AND OTHER MODULES. 
The presence of __init__.py indicates that the directory should be treated as a package.


my_package/
    __init__.py
    module1.py
    module2.py
	module3.py

--------------
# module1.py

def function1():
    return "This is function 1 from module 1"

-----------

# module2.py

def function2():
    return "This is function 2 from module 2"

-----------

cat main.py

from my_package import module1, module2, module3

module1.func1()
module2.func2() 
module3.func3()

=================================================================================


